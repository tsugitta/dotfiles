{
  "BinarySearch": {
    "prefix": "BinarySearch",
    "body": [
      "pub trait BinarySearch<T> {",
      "    fn lower_bound(&self, x: &T) -> usize;",
      "    fn upper_bound(&self, x: &T) -> usize;",
      "}",
      "impl<T: Ord> BinarySearch<T> for [T] {",
      "    fn lower_bound(&self, x: &T) -> usize {",
      "        let mut low: isize = -1;",
      "        let mut high: isize = self.len() as isize;",
      "        while high - low > 1 {",
      "            let mid = (low + high) / 2;",
      "            match self[mid as usize].cmp(x) {",
      "                Ordering::Less => {",
      "                    low = mid;",
      "                }",
      "                Ordering::Equal | Ordering::Greater => {",
      "                    high = mid;",
      "                }",
      "            }",
      "        }",
      "        high as usize",
      "    }",
      "    fn upper_bound(&self, x: &T) -> usize {",
      "        let mut low: isize = -1;",
      "        let mut high: isize = self.len() as isize;",
      "        while high - low > 1 {",
      "            let mid = (low + high) / 2;",
      "            match self[mid as usize].cmp(x) {",
      "                Ordering::Less | Ordering::Equal => {",
      "                    low = mid;",
      "                }",
      "                Ordering::Greater => {",
      "                    high = mid;",
      "                }",
      "            }",
      "        }",
      "        high as usize",
      "    }",
      "}"
    ]
  },
  "FenwickTree": {
    "prefix": "FenwickTree",
    "body": [
      "pub mod fenwick_tree {",
      "    use std::ops::{AddAssign, Sub};",
      "    pub struct FenwickTree<T> {",
      "        n: usize,",
      "        data: Vec<T>,",
      "        init: T,",
      "    }",
      "    impl<T: Copy + AddAssign + Sub<Output = T>> FenwickTree<T> {",
      "        pub fn new(size: usize, init: T) -> FenwickTree<T> {",
      "            FenwickTree {",
      "                n: size + 1,",
      "                data: vec![init; size + 1],",
      "                init: init,",
      "            }",
      "        }",
      "        pub fn add(&mut self, k: usize, value: T) {",
      "            let mut x = k;",
      "            while x < self.n {",
      "                self.data[x] += value;",
      "                x |= x + 1;",
      "            }",
      "        }",
      "        #[doc = \" Returns a sum of range `[l, r)`\"]",
      "        pub fn sum(&self, l: usize, r: usize) -> T {",
      "            self.sum_one(r) - self.sum_one(l)",
      "        }",
      "        #[doc = \" Returns a sum of range `[0, k)`\"]",
      "        pub fn sum_one(&self, k: usize) -> T {",
      "            assert!(k < self.n, \"k={} n={}\", k, self.n);",
      "            let mut result = self.init;",
      "            let mut x = k as isize - 1;",
      "            while x >= 0 {",
      "                result += self.data[x as usize];",
      "                x = (x & (x + 1)) - 1;",
      "            }",
      "            result",
      "        }",
      "    }",
      "}"
    ]
  },
  "UnionFind": {
    "prefix": "UnionFind",
    "body": [
      "pub struct UnionFind {",
      "    parents: Vec<isize>,",
      "}",
      "impl UnionFind {",
      "    pub fn new(size: usize) -> UnionFind {",
      "        UnionFind {",
      "            parents: vec![-1; size],",
      "        }",
      "    }",
      "    pub fn root(&mut self, x: usize) -> usize {",
      "        match self.parents[x].cmp(&0) {",
      "            Ordering::Less => x,",
      "            _ => {",
      "                let root = self.root(self.parents[x] as usize);",
      "                self.parents[x] = root as isize;",
      "                root",
      "            }",
      "        }",
      "    }",
      "    pub fn same(&mut self, x: usize, y: usize) -> bool {",
      "        self.root(x) == self.root(y)",
      "    }",
      "    pub fn merge(&mut self, x: usize, y: usize) {",
      "        let (x_root, y_root) = (self.root(x), self.root(y));",
      "        if x_root == y_root {",
      "            return;",
      "        }",
      "        let new_root = min(x_root, y_root);",
      "        let new_child = max(x_root, y_root);",
      "        self.parents[new_root] += self.parents[new_child];",
      "        self.parents[new_child] = x_root as isize;",
      "    }",
      "    pub fn size(&mut self, x: usize) -> usize {",
      "        let root = self.root(x);",
      "        -self.parents[root] as usize",
      "    }",
      "    pub fn group_count(&self) -> usize {",
      "        self.parents.iter().filter(|&&r| r < 0).count()",
      "    }",
      "}"
    ]
  }
}
