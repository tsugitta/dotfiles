{
  "fenwick": {
    "prefix": "fenwick",
    "body": [
      "type Fenwick struct {",
      "\ttree []int",
      "}",
      "",
      "func NewFenwick(n int) *Fenwick {",
      "\treturn &Fenwick{",
      "\t\ttree: make([]int, n),",
      "\t}",
      "}",
      "",
      "// sum of [0, i)",
      "func (f *Fenwick) Sum(i int) (sum int) {",
      "\tfor i--; i >= 0; i = (i & (i + 1)) - 1 {",
      "\t\tsum += f.tree[i]",
      "\t}",
      "",
      "\treturn",
      "}",
      "",
      "func (f *Fenwick) Add(i, n int) {",
      "\tfor l := len(f.tree); i < l; i |= i + 1 {",
      "\t\tf.tree[i] += n",
      "\t}",
      "}",
      ""
    ],
    "description": "fenwick"
  },
  "pq": {
    "prefix": "pq",
    "body": [
      "type PQ []int",
      "",
      "func (pq *PQ) Len() int { return len(*pq) }",
      "",
      "// less なものから pop される",
      "func (pq *PQ) Less(i, j int) bool    { return (*pq)[i] < (*pq)[j] }",
      "func (pq *PQ) Swap(i, j int)         { (*pq)[i], (*pq)[j] = (*pq)[j], (*pq)[i] }",
      "func (pq *PQ) Push(item interface{}) { *pq = append(*pq, item.(int)) }",
      "",
      "func (pq *PQ) Pop() interface{} {",
      "\told := *pq",
      "\tn := len(old)",
      "\titem := old[n-1]",
      "\t// heap.Pop 直前に取り出されるべき要素が先頭から末尾に移動する",
      "\t*pq = old[0 : n-1]",
      "\treturn item",
      "}",
      ""
    ],
    "description": "pq"
  },
  "uf": {
    "prefix": "uf",
    "body": [
      "type UnionFind struct {",
      "\t// for children, the value is its parent index. for root, the value is -1 * the size of the group",
      "\tparents []int",
      "}",
      "",
      "func (uf *UnionFind) init(n int) {",
      "\tuf.parents = make([]int, n)",
      "",
      "\tfor i := range uf.parents {",
      "\t\tuf.parents[i] = -1",
      "\t}",
      "}",
      "",
      "func (uf *UnionFind) root(x int) int {",
      "\tif uf.parents[x] < 0 {",
      "\t\treturn x",
      "\t}",
      "",
      "\tr := uf.root(uf.parents[x])",
      "\tuf.parents[x] = r",
      "\treturn r",
      "}",
      "",
      "func (uf *UnionFind) same(x, y int) bool {",
      "\treturn uf.root(x) == uf.root(y)",
      "}",
      "",
      "func (uf *UnionFind) merge(x, y int) {",
      "\txr := uf.root(x)",
      "\tyr := uf.root(y)",
      "",
      "\tif xr == yr {",
      "\t\treturn",
      "\t}",
      "",
      "\t// make less index one as a root",
      "\tif xr > yr {",
      "\t\txr, yr = yr, xr",
      "\t}",
      "",
      "\tuf.parents[xr] += uf.parents[yr]",
      "\tuf.parents[yr] = xr",
      "}",
      "",
      "func (uf *UnionFind) size(x int) int {",
      "\treturn -uf.parents[uf.root(x)]",
      "}",
      "",
      "func (uf *UnionFind) groupCount() (res int) {",
      "\tfor _, parent := range uf.parents {",
      "\t\tif parent < 0 {",
      "\t\t\tres++",
      "\t\t}",
      "\t}",
      "",
      "\treturn",
      "}",
      ""
    ],
    "description": "pq"
  },
  "patternmatch": {
    "prefix": "patternmatch",
    "body": [
      "// O(|s|)",
      "func zAlgorithm(s string) []int {",
      "\tn := len(s)",
      "\tz := make([]int, n)",
      "\tz[0] = n",
      "\tfor i, j := 1, 0; i < n; {",
      "\t\tfor i+j < n && s[j:j+1] == s[i+j:i+j+1] {",
      "\t\t\tj++",
      "\t\t}",
      "",
      "\t\tz[i] = j",
      "",
      "\t\tif j == 0 {",
      "\t\t\ti++",
      "\t\t\tcontinue",
      "\t\t}",
      "",
      "\t\tk := 1",
      "",
      "\t\tfor ; i+k < n && k+z[k] < j; k++ {",
      "\t\t\tz[i+k] = z[k]",
      "\t\t}",
      "",
      "\t\ti, j = i+k, j-k",
      "\t}",
      "\treturn z",
      "}",
      "",
      "func getPatternIndices(s, pat string) (res []int) {",
      "\targ := pat + s",
      "\tz := zAlgorithm(arg)",
      "\tls := len(s)",
      "\tlp := len(pat)",
      "",
      "\tfor i := 0; i < ls; i++ {",
      "\t\tif z[lp+i] >= lp {",
      "\t\t\tres = append(res, i)",
      "\t\t}",
      "\t}",
      "",
      "\treturn",
      "}",
      ""
    ],
    "description": "patternmatch"
  },
  "topological": {
    "prefix": "topological",
    "body": [
      "type TopologicalSort struct {",
      "\tedges   [][]int",
      "\tinCount []int",
      "}",
      "",
      "func (t *TopologicalSort) init(n int) {",
      "\tt.edges = make([][]int, n)",
      "\tt.inCount = make([]int, n)",
      "}",
      "",
      "func (t *TopologicalSort) add(from, to int) {",
      "\tt.edges[from] = append(t.edges[from], to)",
      "}",
      "",
      "func (t *TopologicalSort) sort() (res []int, isLoop bool) {",
      "\t// 全ての nodes の入次数をカウント O(E)",
      "\tfor _, edgesForNode := range t.edges {",
      "\t\tfor _, to := range edgesForNode {",
      "\t\t\tt.inCount[to]++",
      "\t\t}",
      "\t}",
      "",
      "\t// inCount が 0 のものの集合",
      "\ts := []int{}",
      "",
      "\tfor node, in := range t.inCount {",
      "\t\tif in == 0 {",
      "\t\t\ts = append(s, node)",
      "\t\t}",
      "\t}",
      "",
      "\tfor len(s) > 0 {",
      "\t\tpopped := s[0]",
      "\t\tres = append(res, popped)",
      "\t\ts = s[1:len(s)]",
      "",
      "\t\tfor _, to := range t.edges[popped] {",
      "\t\t\tt.inCount[to]--",
      "",
      "\t\t\tif t.inCount[to] == 0 {",
      "\t\t\t\ts = append(s, to)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "",
      "\tif len(res) != len(t.edges) {",
      "\t\tisLoop = true",
      "\t\treturn",
      "\t}",
      "",
      "\treturn",
      "}",
      ""
    ],
    "description": "topological"
  }
}
